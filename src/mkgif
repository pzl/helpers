#!/bin/bash
# convenience script for making animated gifs from 
# youtube or other videos using ffmpeg, imagemagick and/or gifsicle
#
# Copyright (c) 2014 Dan Panzarella
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE. 

help="Usage: `basename $0` [OPTIONS] SOURCE GIF_NAME
    OPTIONS:
        -h    help message
        -t   start time (roughly, will ask for exact frame later)
        -d   duration (roughly, will ask for exact stop frame)
"
#        -s    gif size (default 480x270)
#        -z   fuzz amount (default 2)

#fuzz=2
start_time="0:0:0"
duration="0:0:5"
#size="480x270"
readonly frame_rate=25

#@todo: reinstate size


while getopts :ht:d: opt; do
    case "$opt" in
        h)
            echo "$help"
            exit 0
            ;;
        \?)
            echo "$help"
            echo "Invalid arg: -$OPTARG" >&2
            exit 1
            ;;
        :)
            echo "$help"
            echo "-$OPTARG requires an argument" >&2
            exit 1
            ;;
#        s)
#            size="$OPTARG"
#            ;;
        t)
            start_time="$OPTARG"
            ;;
        d)
            duration="$OPTARG"
            ;;
#        z)
#            fuzz="$OPTARG"
#            ;;
    esac
done

input=${@:$OPTIND:1}
if [ -z "$input" ]; then
    echo "Error: input source is required" >&2
    echo "$help"
    exit 1
fi

gif_out=${@:$OPTIND+1:1}
if [ -z "$gif_out" ]; then
    echo "Error: output gif filename is required" >&2
    echo "$help"
    exit 1
fi


if [ "${input:0:4}" == "http" ]; then
    fn=$(youtube-dl --get-filename $input)
    if [ -f "$fn" ]; then
        echo "file exists, not redownloading"
        input="$fn"
    else
        echo "downloading"
        youtube-dl $input
        if [ $? -ne 0 ]; then
            echo "couldn't download video"
            exit 1
        fi
        input="$fn"
    fi
fi

if [ ! -e "$input" ]; then
    echo "invalid source file" >&2
    exit 1
fi


###
# basic alias to ffmpeg
# ffbase VIDEO START DURATION *ARGS
###
ffbase() {
    ffmpeg -v warning -ss $start_time -t $duration -i "$input" "$@"
    local filename="$_"
    if [ "${filename: -3}" = "gif" ]; then
        gifsicle -O3 "$filename" > "${filename%.gif}-opt.gif" &
    fi
}

ffpalette(){
    local rand_name="/tmp/$(cat /dev/urandom | tr -dc '0-9a-zA-Z' | head -c 8)-palette.png"
    ffbase -vf "$scale,palettegen" -y "$rand_name"
    ffbase -i "$rand_name" -lavfi "$scale [x]; [x][1:v] paletteuse" -y "$1"
}

ffdiffuse(){
    local rand_name="/tmp/$(cat /dev/urandom | tr -dc '0-9a-zA-Z' | head -c 8)-palette.png"
    ffbase -vf "$scale,palettegen=stats_mode=${1}" -y "$rand_name"
    ffbase -i "$rand_name" -lavfi "$scale [x]; [x][1:v] paletteuse" -y "04-palette_${1}-${gif_out}" &
    ffbase -i "$rand_name" -lavfi "$scale [x]; [x][1:v] paletteuse=dither=none" -y "05-palette_${1}_nodither-${gif_out}" &
    ffbase -i "$rand_name" -lavfi "$scale [x]; [x][1:v] paletteuse=dither=bayer:bayer_scale=1" -y "05-palette_${1}_bayer1-${gif_out}" &
    ffbase -i "$rand_name" -lavfi "$scale [x]; [x][1:v] paletteuse=dither=bayer:bayer_scale=2" -y "05-palette_${1}_bayer2-${gif_out}" &
    ffbase -i "$rand_name" -lavfi "$scale [x]; [x][1:v] paletteuse=dither=bayer:bayer_scale=3" -y "05-palette_${1}_bayer3-${gif_out}" &
    ffbase -i "$rand_name" -lavfi "$scale [x]; [x][1:v] paletteuse=dither=floyd_steinberg" -y "05-palette_${1}_floydstein-${gif_out}" &
    ffbase -i "$rand_name" -lavfi "$scale [x]; [x][1:v] paletteuse=dither=sierra2" -y "05-palette_${1}_sierra2-${gif_out}" &
    ffbase -i "$rand_name" -lavfi "$scale [x]; [x][1:v] paletteuse=dither=sierra2_4a" -y "05-palette_${1}_sierra24a-${gif_out}" &
}

###
# vid_to_frames VIDEO START_TIME DURATION SIZE
###
vid_to_frames(){
    ffmpeg -ss "$2" -t "$3" -i "$1" -r 25 -s "$4" -f image2 %03d.png
}

###
# frames_to_vid FILENAME.mp4
###
frames_to_vid() {
    ffmpeg -f image2 -i %03d.png -c:v libx264 -pix_fmt yuv444p -r 25 -y "$1"
}

###
# Select an exact starting and ending frame
###
choose_frames(){
    local pid

    sxiv *.png &
    pid="$!"
    echo -n "Review the images and enter the starting frame number: "
    read start_frame
    if [ "$start_frame" == "" ]; then
        echo "empty frame, aborting"
        exit 1
    fi
    echo -n "Enter the ending frame number: "
    read end_frame
    if [ "$end_frame" == "" ]; then
        echo "empty frame, aborting"
        exit 1
    fi
    kill "$pid"
    #no need to generate frame sequence anymore, right?
    #frames=$(seq -f %03g.png $sframe $eframe)
    #frameskip=$(seq -f %03g.png $sframe 2 $eframe)
}

###
# make_all_the_gifs START DURATION
###
make_all_the_gifs(){
    #@todo: frame rate /fps. avail via -r $rate and -vf "fps=$rate"
    #@todo: use size input in scale filter
    #@todo: wtf is -giffflags
    #@todo: transdiff options in lower commands?
    #@todo: fuzz?

    local size="1280:-1"
    local scale="scale=$size:flags=lanczos"

    ###
    # Quick, one-shot method all through ffmpeg
    ###
    ffmpeg -v warning -ss "$1" -t "$2" -i "$input" -vf "$scale" -gifflags -transdiff -y "00-simple_notrans-$gif_out" &
    ffmpeg -v warning -ss "$1" -t "$2" -i "$input" -vf "$scale" -gifflags +transdiff -y "01-simple_trans-$gif_out" &

    ###
    # Dithering
    ###
    ffmpeg -v warning -ss "$1" -t "$2" -i "$input"  -vf "$scale:sws_dither=ed" -y "02-simple_dither_ed-$gif_out" &

    return

    ###
    # Better palette
    ###
    ffpalette "03-palette-$gif_out" &

    ###
    # stats mode full (overall palette quality)
    # with all various diffuse options
    ###
    ffdiffuse "full" &

    ###
    # stats mode diff (care more about movement)
    # with all various diffuse options
    ###
    ffdiffuse "diff" &


}

main(){
    local start_time_exact
    local duration_exact

    # First, convert to frames so we can choose exactly where to start
    vid_to_frames "$input" "$start_time" "$duration" "1280x720"
    choose_frames
    rm *.png

    start_time_exact="$(echo "scale=3;${start_time} + (${start_frame}/${frame_rate})" | bc)"
    duration_exact="$(echo "scale=3;(${end_frame} - ${start_frame} - 1)/${frame_rate}" | bc)"

    make_all_the_gifs $start_time_exact $duration_exact
}


main
exit 0


#@todo: cleanup palettes

exit 0
###################

if ! ffmpeg -ss $start_time -t $duration -i "$input" -r 25 -s $size -f image2 %03d.png; then
    exit 1
fi



#add gimp processing here too
convert +repage -fuzz ${fuzz}% -delay 4 -loop 0 $frames -layers OptimizePlus -layers OptimizeTransparency "$gif_out"
#if [ $? -eq 0 ]; then
    #sxiv "$gif_out" &
#fi
#gifsicle -O3 -k 256 -f $2 > $2.opt


#try skip every other frame
convert +repage -fuzz ${fuzz}% -delay 6 -loop 0 $frameskip -layers OptimizePlus -layers OptimizeTransparency "skip-$gif_out"
#if [ $? -eq 0 ]; then
    #sxiv "skip-$gif_out" &
#fi
